/*
SPDX-FileCopyrightText: 2024 SAP SE or an SAP affiliate company and cf-service-operator contributors
SPDX-License-Identifier: Apache-2.0
*/
// Code generated by counterfeiter. DO NOT EDIT.
package facadefakes

import (
	"context"
	"sync"

	"github.com/sap/cf-service-operator/internal/facade"
)

type FakeSpaceClient struct {
	CreateBindingStub        func(context.Context, string, string, map[string]interface{}, string, int64) error
	createBindingMutex       sync.RWMutex
	createBindingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]interface{}
		arg5 string
		arg6 int64
	}
	createBindingReturns struct {
		result1 error
	}
	createBindingReturnsOnCall map[int]struct {
		result1 error
	}
	CreateInstanceStub        func(context.Context, string, string, map[string]interface{}, []string, string, int64) error
	createInstanceMutex       sync.RWMutex
	createInstanceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]interface{}
		arg5 []string
		arg6 string
		arg7 int64
	}
	createInstanceReturns struct {
		result1 error
	}
	createInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteBindingStub        func(context.Context, string) error
	deleteBindingMutex       sync.RWMutex
	deleteBindingArgsForCall []struct {
		arg1 context.Context
		arg2 string
	}
	deleteBindingReturns struct {
		result1 error
	}
	deleteBindingReturnsOnCall map[int]struct {
		result1 error
	}
	DeleteInstanceStub        func(context.Context, string, string) error
	deleteInstanceMutex       sync.RWMutex
	deleteInstanceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}
	deleteInstanceReturns struct {
		result1 error
	}
	deleteInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	FindServicePlanStub        func(context.Context, string, string, string) (string, error)
	findServicePlanMutex       sync.RWMutex
	findServicePlanArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}
	findServicePlanReturns struct {
		result1 string
		result2 error
	}
	findServicePlanReturnsOnCall map[int]struct {
		result1 string
		result2 error
	}
	GetBindingStub        func(context.Context, map[string]string) (*facade.Binding, error)
	getBindingMutex       sync.RWMutex
	getBindingArgsForCall []struct {
		arg1 context.Context
		arg2 map[string]string
	}
	getBindingReturns struct {
		result1 *facade.Binding
		result2 error
	}
	getBindingReturnsOnCall map[int]struct {
		result1 *facade.Binding
		result2 error
	}
	GetInstanceStub        func(context.Context, map[string]string) (*facade.Instance, error)
	getInstanceMutex       sync.RWMutex
	getInstanceArgsForCall []struct {
		arg1 context.Context
		arg2 map[string]string
	}
	getInstanceReturns struct {
		result1 *facade.Instance
		result2 error
	}
	getInstanceReturnsOnCall map[int]struct {
		result1 *facade.Instance
		result2 error
	}
	GetResourceCacheStub        func() *facade.ResourceCache
	getResourceCacheMutex       sync.RWMutex
	getResourceCacheArgsForCall []struct {
	}
	getResourceCacheReturns struct {
		result1 *facade.ResourceCache
	}
	getResourceCacheReturnsOnCall map[int]struct {
		result1 *facade.ResourceCache
	}
	UpdateBindingStub        func(context.Context, string, int64, map[string]interface{}) error
	updateBindingMutex       sync.RWMutex
	updateBindingArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 map[string]interface{}
	}
	updateBindingReturns struct {
		result1 error
	}
	updateBindingReturnsOnCall map[int]struct {
		result1 error
	}
	UpdateInstanceStub        func(context.Context, string, string, string, string, map[string]interface{}, []string, int64) error
	updateInstanceMutex       sync.RWMutex
	updateInstanceArgsForCall []struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 map[string]interface{}
		arg7 []string
		arg8 int64
	}
	updateInstanceReturns struct {
		result1 error
	}
	updateInstanceReturnsOnCall map[int]struct {
		result1 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeSpaceClient) CreateBinding(arg1 context.Context, arg2 string, arg3 string, arg4 map[string]interface{}, arg5 string, arg6 int64) error {
	fake.createBindingMutex.Lock()
	ret, specificReturn := fake.createBindingReturnsOnCall[len(fake.createBindingArgsForCall)]
	fake.createBindingArgsForCall = append(fake.createBindingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]interface{}
		arg5 string
		arg6 int64
	}{arg1, arg2, arg3, arg4, arg5, arg6})
	stub := fake.CreateBindingStub
	fakeReturns := fake.createBindingReturns
	fake.recordInvocation("CreateBinding", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6})
	fake.createBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) CreateBindingCallCount() int {
	fake.createBindingMutex.RLock()
	defer fake.createBindingMutex.RUnlock()
	return len(fake.createBindingArgsForCall)
}

func (fake *FakeSpaceClient) CreateBindingCalls(stub func(context.Context, string, string, map[string]interface{}, string, int64) error) {
	fake.createBindingMutex.Lock()
	defer fake.createBindingMutex.Unlock()
	fake.CreateBindingStub = stub
}

func (fake *FakeSpaceClient) CreateBindingArgsForCall(i int) (context.Context, string, string, map[string]interface{}, string, int64) {
	fake.createBindingMutex.RLock()
	defer fake.createBindingMutex.RUnlock()
	argsForCall := fake.createBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6
}

func (fake *FakeSpaceClient) CreateBindingReturns(result1 error) {
	fake.createBindingMutex.Lock()
	defer fake.createBindingMutex.Unlock()
	fake.CreateBindingStub = nil
	fake.createBindingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) CreateBindingReturnsOnCall(i int, result1 error) {
	fake.createBindingMutex.Lock()
	defer fake.createBindingMutex.Unlock()
	fake.CreateBindingStub = nil
	if fake.createBindingReturnsOnCall == nil {
		fake.createBindingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createBindingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) CreateInstance(arg1 context.Context, arg2 string, arg3 string, arg4 map[string]interface{}, arg5 []string, arg6 string, arg7 int64) error {
	var arg5Copy []string
	if arg5 != nil {
		arg5Copy = make([]string, len(arg5))
		copy(arg5Copy, arg5)
	}
	fake.createInstanceMutex.Lock()
	ret, specificReturn := fake.createInstanceReturnsOnCall[len(fake.createInstanceArgsForCall)]
	fake.createInstanceArgsForCall = append(fake.createInstanceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 map[string]interface{}
		arg5 []string
		arg6 string
		arg7 int64
	}{arg1, arg2, arg3, arg4, arg5Copy, arg6, arg7})
	stub := fake.CreateInstanceStub
	fakeReturns := fake.createInstanceReturns
	fake.recordInvocation("CreateInstance", []interface{}{arg1, arg2, arg3, arg4, arg5Copy, arg6, arg7})
	fake.createInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) CreateInstanceCallCount() int {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	return len(fake.createInstanceArgsForCall)
}

func (fake *FakeSpaceClient) CreateInstanceCalls(stub func(context.Context, string, string, map[string]interface{}, []string, string, int64) error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = stub
}

func (fake *FakeSpaceClient) CreateInstanceArgsForCall(i int) (context.Context, string, string, map[string]interface{}, []string, string, int64) {
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	argsForCall := fake.createInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7
}

func (fake *FakeSpaceClient) CreateInstanceReturns(result1 error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = nil
	fake.createInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) CreateInstanceReturnsOnCall(i int, result1 error) {
	fake.createInstanceMutex.Lock()
	defer fake.createInstanceMutex.Unlock()
	fake.CreateInstanceStub = nil
	if fake.createInstanceReturnsOnCall == nil {
		fake.createInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.createInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) DeleteBinding(arg1 context.Context, arg2 string) error {
	fake.deleteBindingMutex.Lock()
	ret, specificReturn := fake.deleteBindingReturnsOnCall[len(fake.deleteBindingArgsForCall)]
	fake.deleteBindingArgsForCall = append(fake.deleteBindingArgsForCall, struct {
		arg1 context.Context
		arg2 string
	}{arg1, arg2})
	stub := fake.DeleteBindingStub
	fakeReturns := fake.deleteBindingReturns
	fake.recordInvocation("DeleteBinding", []interface{}{arg1, arg2})
	fake.deleteBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) DeleteBindingCallCount() int {
	fake.deleteBindingMutex.RLock()
	defer fake.deleteBindingMutex.RUnlock()
	return len(fake.deleteBindingArgsForCall)
}

func (fake *FakeSpaceClient) DeleteBindingCalls(stub func(context.Context, string) error) {
	fake.deleteBindingMutex.Lock()
	defer fake.deleteBindingMutex.Unlock()
	fake.DeleteBindingStub = stub
}

func (fake *FakeSpaceClient) DeleteBindingArgsForCall(i int) (context.Context, string) {
	fake.deleteBindingMutex.RLock()
	defer fake.deleteBindingMutex.RUnlock()
	argsForCall := fake.deleteBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpaceClient) DeleteBindingReturns(result1 error) {
	fake.deleteBindingMutex.Lock()
	defer fake.deleteBindingMutex.Unlock()
	fake.DeleteBindingStub = nil
	fake.deleteBindingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) DeleteBindingReturnsOnCall(i int, result1 error) {
	fake.deleteBindingMutex.Lock()
	defer fake.deleteBindingMutex.Unlock()
	fake.DeleteBindingStub = nil
	if fake.deleteBindingReturnsOnCall == nil {
		fake.deleteBindingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteBindingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) DeleteInstance(arg1 context.Context, arg2 string, arg3 string) error {
	fake.deleteInstanceMutex.Lock()
	ret, specificReturn := fake.deleteInstanceReturnsOnCall[len(fake.deleteInstanceArgsForCall)]
	fake.deleteInstanceArgsForCall = append(fake.deleteInstanceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
	}{arg1, arg2, arg3})
	stub := fake.DeleteInstanceStub
	fakeReturns := fake.deleteInstanceReturns
	fake.recordInvocation("DeleteInstance", []interface{}{arg1, arg2, arg3})
	fake.deleteInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) DeleteInstanceCallCount() int {
	fake.deleteInstanceMutex.RLock()
	defer fake.deleteInstanceMutex.RUnlock()
	return len(fake.deleteInstanceArgsForCall)
}

func (fake *FakeSpaceClient) DeleteInstanceCalls(stub func(context.Context, string, string) error) {
	fake.deleteInstanceMutex.Lock()
	defer fake.deleteInstanceMutex.Unlock()
	fake.DeleteInstanceStub = stub
}

func (fake *FakeSpaceClient) DeleteInstanceArgsForCall(i int) (context.Context, string, string) {
	fake.deleteInstanceMutex.RLock()
	defer fake.deleteInstanceMutex.RUnlock()
	argsForCall := fake.deleteInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeSpaceClient) DeleteInstanceReturns(result1 error) {
	fake.deleteInstanceMutex.Lock()
	defer fake.deleteInstanceMutex.Unlock()
	fake.DeleteInstanceStub = nil
	fake.deleteInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) DeleteInstanceReturnsOnCall(i int, result1 error) {
	fake.deleteInstanceMutex.Lock()
	defer fake.deleteInstanceMutex.Unlock()
	fake.DeleteInstanceStub = nil
	if fake.deleteInstanceReturnsOnCall == nil {
		fake.deleteInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.deleteInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) FindServicePlan(arg1 context.Context, arg2 string, arg3 string, arg4 string) (string, error) {
	fake.findServicePlanMutex.Lock()
	ret, specificReturn := fake.findServicePlanReturnsOnCall[len(fake.findServicePlanArgsForCall)]
	fake.findServicePlanArgsForCall = append(fake.findServicePlanArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
	}{arg1, arg2, arg3, arg4})
	stub := fake.FindServicePlanStub
	fakeReturns := fake.findServicePlanReturns
	fake.recordInvocation("FindServicePlan", []interface{}{arg1, arg2, arg3, arg4})
	fake.findServicePlanMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSpaceClient) FindServicePlanCallCount() int {
	fake.findServicePlanMutex.RLock()
	defer fake.findServicePlanMutex.RUnlock()
	return len(fake.findServicePlanArgsForCall)
}

func (fake *FakeSpaceClient) FindServicePlanCalls(stub func(context.Context, string, string, string) (string, error)) {
	fake.findServicePlanMutex.Lock()
	defer fake.findServicePlanMutex.Unlock()
	fake.FindServicePlanStub = stub
}

func (fake *FakeSpaceClient) FindServicePlanArgsForCall(i int) (context.Context, string, string, string) {
	fake.findServicePlanMutex.RLock()
	defer fake.findServicePlanMutex.RUnlock()
	argsForCall := fake.findServicePlanArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSpaceClient) FindServicePlanReturns(result1 string, result2 error) {
	fake.findServicePlanMutex.Lock()
	defer fake.findServicePlanMutex.Unlock()
	fake.FindServicePlanStub = nil
	fake.findServicePlanReturns = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSpaceClient) FindServicePlanReturnsOnCall(i int, result1 string, result2 error) {
	fake.findServicePlanMutex.Lock()
	defer fake.findServicePlanMutex.Unlock()
	fake.FindServicePlanStub = nil
	if fake.findServicePlanReturnsOnCall == nil {
		fake.findServicePlanReturnsOnCall = make(map[int]struct {
			result1 string
			result2 error
		})
	}
	fake.findServicePlanReturnsOnCall[i] = struct {
		result1 string
		result2 error
	}{result1, result2}
}

func (fake *FakeSpaceClient) GetBinding(arg1 context.Context, arg2 map[string]string) (*facade.Binding, error) {
	fake.getBindingMutex.Lock()
	ret, specificReturn := fake.getBindingReturnsOnCall[len(fake.getBindingArgsForCall)]
	fake.getBindingArgsForCall = append(fake.getBindingArgsForCall, struct {
		arg1 context.Context
		arg2 map[string]string
	}{arg1, arg2})
	stub := fake.GetBindingStub
	fakeReturns := fake.getBindingReturns
	fake.recordInvocation("GetBinding", []interface{}{arg1, arg2})
	fake.getBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSpaceClient) GetBindingCallCount() int {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	return len(fake.getBindingArgsForCall)
}

func (fake *FakeSpaceClient) GetBindingCalls(stub func(context.Context, map[string]string) (*facade.Binding, error)) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = stub
}

func (fake *FakeSpaceClient) GetBindingArgsForCall(i int) (context.Context, map[string]string) {
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	argsForCall := fake.getBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpaceClient) GetBindingReturns(result1 *facade.Binding, result2 error) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = nil
	fake.getBindingReturns = struct {
		result1 *facade.Binding
		result2 error
	}{result1, result2}
}

func (fake *FakeSpaceClient) GetBindingReturnsOnCall(i int, result1 *facade.Binding, result2 error) {
	fake.getBindingMutex.Lock()
	defer fake.getBindingMutex.Unlock()
	fake.GetBindingStub = nil
	if fake.getBindingReturnsOnCall == nil {
		fake.getBindingReturnsOnCall = make(map[int]struct {
			result1 *facade.Binding
			result2 error
		})
	}
	fake.getBindingReturnsOnCall[i] = struct {
		result1 *facade.Binding
		result2 error
	}{result1, result2}
}

func (fake *FakeSpaceClient) GetInstance(arg1 context.Context, arg2 map[string]string) (*facade.Instance, error) {
	fake.getInstanceMutex.Lock()
	ret, specificReturn := fake.getInstanceReturnsOnCall[len(fake.getInstanceArgsForCall)]
	fake.getInstanceArgsForCall = append(fake.getInstanceArgsForCall, struct {
		arg1 context.Context
		arg2 map[string]string
	}{arg1, arg2})
	stub := fake.GetInstanceStub
	fakeReturns := fake.getInstanceReturns
	fake.recordInvocation("GetInstance", []interface{}{arg1, arg2})
	fake.getInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeSpaceClient) GetInstanceCallCount() int {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	return len(fake.getInstanceArgsForCall)
}

func (fake *FakeSpaceClient) GetInstanceCalls(stub func(context.Context, map[string]string) (*facade.Instance, error)) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = stub
}

func (fake *FakeSpaceClient) GetInstanceArgsForCall(i int) (context.Context, map[string]string) {
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	argsForCall := fake.getInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2
}

func (fake *FakeSpaceClient) GetInstanceReturns(result1 *facade.Instance, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	fake.getInstanceReturns = struct {
		result1 *facade.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeSpaceClient) GetInstanceReturnsOnCall(i int, result1 *facade.Instance, result2 error) {
	fake.getInstanceMutex.Lock()
	defer fake.getInstanceMutex.Unlock()
	fake.GetInstanceStub = nil
	if fake.getInstanceReturnsOnCall == nil {
		fake.getInstanceReturnsOnCall = make(map[int]struct {
			result1 *facade.Instance
			result2 error
		})
	}
	fake.getInstanceReturnsOnCall[i] = struct {
		result1 *facade.Instance
		result2 error
	}{result1, result2}
}

func (fake *FakeSpaceClient) GetResourceCache() *facade.ResourceCache {
	fake.getResourceCacheMutex.Lock()
	ret, specificReturn := fake.getResourceCacheReturnsOnCall[len(fake.getResourceCacheArgsForCall)]
	fake.getResourceCacheArgsForCall = append(fake.getResourceCacheArgsForCall, struct {
	}{})
	stub := fake.GetResourceCacheStub
	fakeReturns := fake.getResourceCacheReturns
	fake.recordInvocation("GetResourceCache", []interface{}{})
	fake.getResourceCacheMutex.Unlock()
	if stub != nil {
		return stub()
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) GetResourceCacheCallCount() int {
	fake.getResourceCacheMutex.RLock()
	defer fake.getResourceCacheMutex.RUnlock()
	return len(fake.getResourceCacheArgsForCall)
}

func (fake *FakeSpaceClient) GetResourceCacheCalls(stub func() *facade.ResourceCache) {
	fake.getResourceCacheMutex.Lock()
	defer fake.getResourceCacheMutex.Unlock()
	fake.GetResourceCacheStub = stub
}

func (fake *FakeSpaceClient) GetResourceCacheReturns(result1 *facade.ResourceCache) {
	fake.getResourceCacheMutex.Lock()
	defer fake.getResourceCacheMutex.Unlock()
	fake.GetResourceCacheStub = nil
	fake.getResourceCacheReturns = struct {
		result1 *facade.ResourceCache
	}{result1}
}

func (fake *FakeSpaceClient) GetResourceCacheReturnsOnCall(i int, result1 *facade.ResourceCache) {
	fake.getResourceCacheMutex.Lock()
	defer fake.getResourceCacheMutex.Unlock()
	fake.GetResourceCacheStub = nil
	if fake.getResourceCacheReturnsOnCall == nil {
		fake.getResourceCacheReturnsOnCall = make(map[int]struct {
			result1 *facade.ResourceCache
		})
	}
	fake.getResourceCacheReturnsOnCall[i] = struct {
		result1 *facade.ResourceCache
	}{result1}
}

func (fake *FakeSpaceClient) UpdateBinding(arg1 context.Context, arg2 string, arg3 int64, arg4 map[string]interface{}) error {
	fake.updateBindingMutex.Lock()
	ret, specificReturn := fake.updateBindingReturnsOnCall[len(fake.updateBindingArgsForCall)]
	fake.updateBindingArgsForCall = append(fake.updateBindingArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 int64
		arg4 map[string]interface{}
	}{arg1, arg2, arg3, arg4})
	stub := fake.UpdateBindingStub
	fakeReturns := fake.updateBindingReturns
	fake.recordInvocation("UpdateBinding", []interface{}{arg1, arg2, arg3, arg4})
	fake.updateBindingMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) UpdateBindingCallCount() int {
	fake.updateBindingMutex.RLock()
	defer fake.updateBindingMutex.RUnlock()
	return len(fake.updateBindingArgsForCall)
}

func (fake *FakeSpaceClient) UpdateBindingCalls(stub func(context.Context, string, int64, map[string]interface{}) error) {
	fake.updateBindingMutex.Lock()
	defer fake.updateBindingMutex.Unlock()
	fake.UpdateBindingStub = stub
}

func (fake *FakeSpaceClient) UpdateBindingArgsForCall(i int) (context.Context, string, int64, map[string]interface{}) {
	fake.updateBindingMutex.RLock()
	defer fake.updateBindingMutex.RUnlock()
	argsForCall := fake.updateBindingArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4
}

func (fake *FakeSpaceClient) UpdateBindingReturns(result1 error) {
	fake.updateBindingMutex.Lock()
	defer fake.updateBindingMutex.Unlock()
	fake.UpdateBindingStub = nil
	fake.updateBindingReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) UpdateBindingReturnsOnCall(i int, result1 error) {
	fake.updateBindingMutex.Lock()
	defer fake.updateBindingMutex.Unlock()
	fake.UpdateBindingStub = nil
	if fake.updateBindingReturnsOnCall == nil {
		fake.updateBindingReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateBindingReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) UpdateInstance(arg1 context.Context, arg2 string, arg3 string, arg4 string, arg5 string, arg6 map[string]interface{}, arg7 []string, arg8 int64) error {
	var arg7Copy []string
	if arg7 != nil {
		arg7Copy = make([]string, len(arg7))
		copy(arg7Copy, arg7)
	}
	fake.updateInstanceMutex.Lock()
	ret, specificReturn := fake.updateInstanceReturnsOnCall[len(fake.updateInstanceArgsForCall)]
	fake.updateInstanceArgsForCall = append(fake.updateInstanceArgsForCall, struct {
		arg1 context.Context
		arg2 string
		arg3 string
		arg4 string
		arg5 string
		arg6 map[string]interface{}
		arg7 []string
		arg8 int64
	}{arg1, arg2, arg3, arg4, arg5, arg6, arg7Copy, arg8})
	stub := fake.UpdateInstanceStub
	fakeReturns := fake.updateInstanceReturns
	fake.recordInvocation("UpdateInstance", []interface{}{arg1, arg2, arg3, arg4, arg5, arg6, arg7Copy, arg8})
	fake.updateInstanceMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3, arg4, arg5, arg6, arg7, arg8)
	}
	if specificReturn {
		return ret.result1
	}
	return fakeReturns.result1
}

func (fake *FakeSpaceClient) UpdateInstanceCallCount() int {
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	return len(fake.updateInstanceArgsForCall)
}

func (fake *FakeSpaceClient) UpdateInstanceCalls(stub func(context.Context, string, string, string, string, map[string]interface{}, []string, int64) error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = stub
}

func (fake *FakeSpaceClient) UpdateInstanceArgsForCall(i int) (context.Context, string, string, string, string, map[string]interface{}, []string, int64) {
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	argsForCall := fake.updateInstanceArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3, argsForCall.arg4, argsForCall.arg5, argsForCall.arg6, argsForCall.arg7, argsForCall.arg8
}

func (fake *FakeSpaceClient) UpdateInstanceReturns(result1 error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = nil
	fake.updateInstanceReturns = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) UpdateInstanceReturnsOnCall(i int, result1 error) {
	fake.updateInstanceMutex.Lock()
	defer fake.updateInstanceMutex.Unlock()
	fake.UpdateInstanceStub = nil
	if fake.updateInstanceReturnsOnCall == nil {
		fake.updateInstanceReturnsOnCall = make(map[int]struct {
			result1 error
		})
	}
	fake.updateInstanceReturnsOnCall[i] = struct {
		result1 error
	}{result1}
}

func (fake *FakeSpaceClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.createBindingMutex.RLock()
	defer fake.createBindingMutex.RUnlock()
	fake.createInstanceMutex.RLock()
	defer fake.createInstanceMutex.RUnlock()
	fake.deleteBindingMutex.RLock()
	defer fake.deleteBindingMutex.RUnlock()
	fake.deleteInstanceMutex.RLock()
	defer fake.deleteInstanceMutex.RUnlock()
	fake.findServicePlanMutex.RLock()
	defer fake.findServicePlanMutex.RUnlock()
	fake.getBindingMutex.RLock()
	defer fake.getBindingMutex.RUnlock()
	fake.getInstanceMutex.RLock()
	defer fake.getInstanceMutex.RUnlock()
	fake.getResourceCacheMutex.RLock()
	defer fake.getResourceCacheMutex.RUnlock()
	fake.updateBindingMutex.RLock()
	defer fake.updateBindingMutex.RUnlock()
	fake.updateInstanceMutex.RLock()
	defer fake.updateInstanceMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeSpaceClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ facade.SpaceClient = new(FakeSpaceClient)
